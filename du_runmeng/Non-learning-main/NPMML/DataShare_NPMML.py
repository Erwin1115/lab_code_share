import torch
import numpy as np
from torchvision import datasets, transforms
import random
import os
from PIL import Image
import pickle

from utils_NPMML import mod_pow, CSP_PA
from utils_NPMML import dataset_path, enc_data_path, batch_size
from utils_NPMML import Precision, Gama
from MyMatrix_NPMML import load_matrix_float

from rsa.key import newkeys
from rsa import encrypt, transform, decrypt, PublicKey, PrivateKey
import struct

import time
from tqdm import tqdm


# Create new RSA keys
# pub_key, priv_key = newkeys(2048)
# print(f"n = {pub_key.n}")
# print(f"e = {pub_key.e}")
# print(f"d = {priv_key.d}")
# print(f"p = {priv_key.p}")
# print(f"q = {priv_key.q}")
    

# 1024
n = 120469990590334531408684408810216512792107783437669420407936743079294741982565937631337741290919249236189097256605011181715787211807729769162468691405712077620859482987435213785180441832638349618249250341572537113524860920041412925797961661769931744240027862867703634479097528955728653261505409871304170834979
e = 65537
d = 21914998059385816919516235437011173314425576302606082519850189221223917999239377884871271978734749674135929589289179292741743063295111987243159607457906774446757922569609640387359074312768158310453409866019013462290846452038377172909063019338709881523364045318191941030084084685094994179359855705501122823777
p = 45711295345787511554547208496781649696368125684466477515287251373391672690295453843894297598537669763490619135509523254675346806891134956294236918676994089581076153
q = 2635453440534284674902871431198392677648744239944117293596635956484868819499003621574758561415748546825321804087073660244150177500921886030246843

# 1280
# n = 16380239686998077494632614432638827849882144721277191154417296832758914430153367572194296859191389599073718932283248953847141226366569459269011301145999582267309032379805133747196956768146783157226835947644422856914163358394496050049658666291589463771678652157328939932515503377511303358180287199248157983828134428322603709115549795296993865427809608499764315838268987815396658404256369
# e = 65537
# d = 12259248613875653493968828376436240096569408371361596486458244844133725893534835681348826871026724879762070889872302332075750034515676112847486691638465805737663315824603842183289795522319910307279241108479039613352036874281700007201599041377343854089869258598369283363453428194522457125648572877103421504173518366471895527181585874068691492112676334900584994905840603490649295817002053
# p = 4146354698470318649755742761498089383864324167403034621288852687388719307353667141005160102372124200883281185119915000875225906733410846105767874640766846654671998214384773134853857704458478227093935537599
# q = 3950515785116287281204029347578379809042461900466843745721631202704323253464994632161826734047952799736323377086915744562085944822949556156899165491402672216367998705216152575329231

# # 1536
# n = 1755033209446191176784095161978701466749801515773116496408605475559925179691015561103864372604668520855919346882674944184098656019363975840749020862728456427502285149238276044291423193186047041779613696713536177640918157531487048847234705290507761571922164131548089421917016482034056737278844550351541620445511522624122591113858468280889157492128882672911997584506237961544389097823636583469520182986984037216915526774964216251640611168224235798280253081832499873
# e = 65537
# d = 346148881781306241529383616334844365155682048199998532623977819813045956828754247872629978184658212926798807968101321826199844785484516406267022348774402669971077984025114914453071336727693426034809140542276403133901512610553096960536080166159373567225661142861216957531485437573374830423053526101518003608125565050011254356793492488275568900838578287788588001001867099147635349532006382764331640357144797363651790117929677384954422763762559057808947485510594937
# p = 361464813807666463152927086213665737391270696761287503982622595887885178057484453743209702919857370596938420377720555354823482619653968990118557313692473234054453603179313490627728912665472334149194980259506660649844038773750440915885487808180847
# q = 4855336238564108671802543858467031680668483607819408924404672212185392579685125696814783857406959048304578376413158272588496445985433151363791158994363861863158351616140787528687095419205573771479247846729395207371759

# # 1792
# n = 150718899484113266726143077665535641420585209834644872655587628517370027034268924530011292291817106175752425229355664012232061493381463879383618872818427822369398597926773847765472945866046569166360920075960681239332907842864538503673166030911646226116914789681164377284501942187954405806117287457832358954924425035337184865074962059547994294165868897218449488165287735650743654532432237292781782594158750461965088535394709207720533750077044686141306751185714745274355870046044027345866512788738057062600055365110878142126442407232935774163
# e = 65537
# d = 50741745856805699330845489808999166765396525165808695397605710295058551299023598132813054505495409168283588053473661760011721695988046737487528675555270938138126717192674949678767643889534942125617396898789942641021732435799062782016948217129782601172515163408019784135288433378549713470020980737028728105321326964632280631702923464457093270044613541915189179489358776698139667654413436115503024596880721827125216498464055002171983750047854901567997789923300366944595247137686641525722958309692348009875491378440434077655823756708845190913
# p = 21829915419607846757287622598506067307457447055132679138781048041686531191749540614521876078177069907004786241759085190952120972117109135971410640398620573941452707933563019614589143390557691305013190874696292754905175126206625562297446375423417007635908488295813936864810729530683673033
# q = 6904236529873865423789459919080044392625303930729859218354468581458664006845840735826634381680905530499915805102519563064949609646358953807878184498506362507705135512894261012868982116617509200837625197724848930685710608149981728085458798032695563047611


# # 2048
# n = 16495294585145614809550887748600948164117732229878947552246039898552627262072317417491509772223047514239708703366399795039480396979916984019403751517309333058238260541506922825220437247444434755449357239481182396756199414448946002567115769582252533508454137801768053094169566385515760091719619053577783860630855070028935375764948404508397183289749450328267407633456036964440188067463868090008532683752266613250130801512130346956413687577242081425901723939763765928275162266853242342709022486840584281482560361311039188570753277562579668169507134704517075986856788449168637913462854291361957351859128675192104481156871
# e = 65537
# d = 5474604460404081171285554105616967873380301108260936390266622119313032265397179854858443765439728801779573431907511206523089828870869498442193737877122774972149173826057297074497913095948302491200069721164459745057663510134412995740380778860545567486189266388852967374937550367751854643253782683991005293453180133528670724552042929506505494478207530971678561149002948408778538988137987081861681296091545881594105196400924778500826420372366836722148127851777614488187479876071629444908986323335821965038105683801378303538848484472043503018178311891205556961483589379509492465457741035162714472225683016709682180283473
# p = 3231036442088310217491711513534094216176002519116298167435687618899503034814283955885808160972633402774877485557902543960141163106333311698490916302706945234548383576047649263641932271063737724995621658651099136833702584421465686396519784120978338949578335349098881233192671446317839111881496691949570438599904715844714337081001
# q = 5105264171667540672139000531627552887248394232320706197029391662462742585351038071522797500670502748674409730523119352613886774366223753394994115227398097047673428416611983750401053093383447508907157786030778104929395814710246310615521666318519471495201826277412964187705966330864878605871


pub_key = PublicKey(n, e)
priv_key = PrivateKey(n, e, d, p, q)



def expand_labels(lables):
    result = []
    for i in range(len(lables)):
        labels_tmp = np.full((10,1), (0.01)*Precision) 
        labels_tmp[lables[i]][0] = (0.99)*Precision
        result.append(labels_tmp)
    return np.array(result)
def load_data(type="MINIST"):
    # Define a transform to convert the data to tensor
    transform = transforms.ToTensor()

    if type == "MINIST":
        # Download and load the training and test data
        trainset = datasets.MNIST(dataset_path, download=True, train=True, transform=transform)
        testset = datasets.MNIST(dataset_path, download=True, train=False, transform=transform)
    elif type == "FASHION":
        trainset = datasets.FashionMNIST(dataset_path, download=True, train=True, transform=transform)
        testset = datasets.FashionMNIST(dataset_path, download=True, train=False, transform=transform)
        
        
    # Access the data and the labels
    train_data = trainset.data.numpy().reshape(-1, 28*28)
    train_labels = trainset.targets.numpy()

    test_data = testset.data.numpy().reshape(-1, 28*28)
    test_labels = testset.targets.numpy()
    
    tmean = np.mean(train_data)
    tstd = np.std(test_data)

    train_data = (train_data - tmean) / tstd
    test_data = (test_data - tmean) / tstd
    
    train_labels = expand_labels(train_labels)
    # test_labels = expand_labels(test_labels)
    
    return train_data,train_labels,test_data,test_labels



# Define a custom function.
def pailliar_y(x):
    assert type(x) is int or type(x) is np.int32
    return mod_pow(CSP_PA.g,x,CSP_PA.public_key.nsquare)
# Vectorize the function.
vfunc_pailliar = np.vectorize(pailliar_y)

def float_to_bytes(float_val):
    return struct.pack('d', float_val)

def bytes_to_float(bytes_val):
    return struct.unpack('d', bytes_val)[0]

def encrypt_matrix(matrix):
    # Convert to integers
    global pub_key, priv_key
    matrix = (matrix * Precision)

    # Encrypt each element of the matrix
    encrypted_matrix = np.empty(matrix.shape, dtype=object)
    for i in range(matrix.shape[0]):
        for j in range(matrix.shape[1]):
            bytes_val = float_to_bytes(matrix[i][j])
            int_val = int.from_bytes(bytes_val, byteorder='big', signed=False)
            encrypted_matrix[i][j] = encrypt(int_val.to_bytes((int_val.bit_length() + 7) // 8, byteorder='big'), pub_key)
    
    return encrypted_matrix, priv_key


def decrypt_matrix(encrypted_matrix):
    global pub_key, priv_key
    # Decrypt each element of the matrix
    decrypted_matrix = np.empty(encrypted_matrix.shape, dtype=float)
    for i in range(encrypted_matrix.shape[0]):
        for j in range(encrypted_matrix.shape[1]):
            encrypted_value = encrypted_matrix[i][j]
            decrypted_bytes = decrypt(encrypted_value, priv_key)
            int_val = int.from_bytes(decrypted_bytes, byteorder='big', signed=False)
            bytes_val = int_val.to_bytes((int_val.bit_length() + 7) // 8, byteorder='big')
            bytes_val = bytes_val.rjust(8, b'\0')  # pad with leading zeros if less than 8 bytes
            decrypted_matrix[i][j] = bytes_to_float(bytes_val) / Precision

    return decrypted_matrix

# def decrypt_matrix(encrypted_matrix):
#     global pub_key, priv_key
#     decrypted_matrix = np.empty(encrypted_matrix.shape, dtype=float)
#     for i in range(encrypted_matrix.shape[0]):
#         for j in range(encrypted_matrix.shape[1]):
#             # int_val = int.from_bytes(decrypt(encrypted_matrix[i][j], priv_key), byteorder='big', signed=False)
#             int_val = decrypt(encrypted_matrix[i][j], priv_key)
#             bytes_val = int_val.to_bytes((int_val.bit_length() + 7) // 8, byteorder='big')
#             # bytes_val = decrypt(encrypted_matrix[i][j], priv_key)
#             decrypted_matrix[i][j] = bytes_to_float(bytes_val)
    
#     return decrypted_matrix


def encrypt_data(train_data,train_labels,test_data,test_labels):
    A_Matrix, A_Matrix_ = load_matrix_float()

    train_data_list = train_data.tolist()
    train_label_list = train_labels.tolist()
    train_data = np.array(train_data_list)
    
    enc_result = []
    print("Encrypting data:")
    start = time.time()
    # for i in tqdm(range(len(train_data_list)//100)):
    for i in tqdm(range(batch_size)):
        data = train_data[i].T
        label = np.array(train_label_list[i])
        enc_matrix = A_Matrix[i] @ data
        enc_matrix, priv_key = encrypt_matrix(enc_matrix[:,np.newaxis])
        
        
        # TODO: Hardcode the shape of Y here
        # labels_tmp = np.full((10,1), 0.01) 
        # labels_tmp[label][0] = 0.99
        # enc_y = (labels_tmp * Precision).astype(int)
        # enc_y = vfunc_pailliar(enc_y)
        # enc_y = CSP_PA.encryMatrix(label)
        
        enc_result.append((i, enc_matrix, label))
        a = 1
    end = time.time()
    print(f"Encrypting cost {end-start} seconds, each x costs {(end-start)/batch_size} seconds")
    
    with open(enc_data_path, "wb") as f:
        pickle.dump(enc_result, f)
    print("All encrypted")
    return enc_result

# def verify_dec_data(enc_result, train_data):
#     A_Matrix, A_Matrix_ = load_matrix_float()
#     print("Verifying encrypted data:")
#     for i, enc_data, enc_label in tqdm(enc_result):
#         assert (A_Matrix_[i] @ enc_data).any() == train_data[i].any()
#     print("All Verification passed")
#     return None 

def load_enc_data():
    if(os.path.exists(enc_data_path)):
        with open(enc_data_path, "rb") as f:
            return pickle.load(f)
    else:
        train_data,train_labels,test_data,test_labels = load_data("FASHION")
        start_time = time.time()
        enc_data =  encrypt_data(train_data,train_labels, None, None)
        end_time = time.time()
        print(f"Encryption time:{end_time-start_time}s")
        return enc_data

def test_enc_dec():
    print("Loading encrypted data:")
    enc_data = load_enc_data()
    a = 1

if __name__ == "__main__":
    test_enc_dec()
